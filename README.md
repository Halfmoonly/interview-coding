题目搜集不限于leetcode

经验总结，尽量不会成为我们的心智负担

1. 分支判断
   1. if条件尽可能的简短，这样else也会更加清晰，除非你清楚所有的可能性
   2. 德摩根定律：`if/while(b1||b2||b3) + if/while(!b1&&!b2&&!b3) == 1`
   3. 德摩根定律：`if/while(b1&&b2&&b3) + if/while(!b1||!b2||!b3) == 1`
2. 递归recursion
   1. 递归三要素，终止条件、递归调用（递）、返回结果（归）
   2. 当定义带返回值的递归函数，子递归一旦找到答案之后要立刻返回，请注意这有别于终止条件的返回，避免不必要的遍历浪费性能且逻辑错误
   3. 当递归函数返回值为void，则递归代码不需要显式返回结果，但是返回结果（归）应当蕴含于递归方法的引用变量参数当中，或者类成员变量赋值体现
   4. 小心引用变量，当递归参数存在引用变量，修改引用可能会污染其他子递归分支，从而导致计算混乱，需要回溯来弥补。若非回溯场景则难以弥补
   5. 禁用自增自减++--，即使不是引用变量，比如++k/k++操作，会导致当前递归层状态丢失，从而导致计算错误
3. 迭代iteration
   1. 单向链表
   2. 双向链表
   3. 有趣的是迭代程序和递归程序可以相互转换，虽然他们属于完全不同的解决范式
   4. 当迭代与递归同时出现的时候，一定是复杂问题，请警惕是否过度同时使用了迭代与递归
4. 字符串
   1. 求字符`charAt(index)`
   2. 求数值`charAt(index)-'0'`
5. 双指针
   1. `while|if|continue|break`
   2. 二分查找法
   3. 快慢指针法
   4. 滑动窗口法
   5. 跨数组多指针
6. 哈希表
   1. `HashMap`查找
   2. `HashMap`缓存
7. 栈Stack
   1. `push/pop`
8. 队列Queue
   1. `Queue`是接口，实现类是`LinkedList/ArrayDeque`
   2. `offer/poll`
9. 动态规划dp
   1. 推导转移方程并填充`dp[]`数组
10. 二叉树TreeNode
    1. 递归：深度优先dfs递归遍历
    2. 迭代：广度优先bfs层序遍历
11. 二叉搜索树BST
    1. 递归：中序遍历天然有序
    2. 迭代：二分查找
    3. 迭代：叶子插入（二分查找+叶子插入）
    4. 迭代+递归：按出度`0|1|2`删除算法
12. 排序算法
    1. 堆PriorityQueue
