题目搜集不限于leetcode

经验总结，尽量不会成为我们的心智负担

1. 条件分支
   1. if条件尽可能的简短，这样else也会更加清晰，除非你清楚所有的可能性
   2. 德摩根定律：`if/while(b1||b2||b3) + if/while(!b1&&!b2&&!b3) == 1`
   3. 德摩根定律：`if/while(b1&&b2&&b3) + if/while(!b1||!b2||!b3) == 1`
2. 递归`Recursion`
   1. 递归属于“自上而下”的解决问题，将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。
   2. 递归三要素，终止条件、递归调用（子问题）、返回结果（归）
   3. 当定义带返回值的递归函数，子递归一旦找到答案之后要立刻返回，请注意这有别于终止条件的返回，避免不必要的遍历浪费性能且逻辑错误
   4. 当递归函数返回值为void，则递归代码不需要显式返回结果，但是返回结果（归）应当蕴含于递归方法的引用变量参数当中，或者类成员变量赋值体现
   5. 小心引用类型的变量，当递归参数存在引用变量，修改引用可能会污染其他子递归分支，从而导致计算混乱，需要回溯来弥补。若非回溯场景则难以弥补
   6. 禁用自增自减++--，即使不是引用变量，比如++k/k++操作，会导致当前递归层状态丢失，从而导致计算错误
   7. 目标变量往往定义在递归函数外部，作为成员变量或者外部变量传递给递归函数。否则中间结果会被递归函数内的局部变量初始化给反复覆盖，产生预期之外的错误
3. 迭代`Iteration`
   1. 迭代iteration属于“自下而上”的解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。迭代和递归属于完全不同的解决范式。
   2. for
   3. while
   4. 当迭代与递归同时出现的时候，一定是复杂问题，请警惕是否过度同时使用了迭代与递归
4. 链表`ListNode`
   1. 单向链表
   2. 双向链表
   3. 循环链表
5. 二叉树`TreeNode`
    1. 递归：深度优先dfs递归遍历，需要推演算法但不是根，而是叶子小树林
    2. 迭代：广度优先bfs层序遍历
6. 二叉搜索树`BST`
    1. 递归：中序遍历天然有序
    2. 迭代：二分查找
    3. 迭代：叶子插入（二分查找+叶子插入）
    4. 迭代+递归：按出度`0|1|2`删除算法
7. 字符串`String`
   1. 求字符`charAt(index)`
   2. 求数值`charAt(index)-'0'`
8. 双指针
   1. `while|if|continue|break`
   2. 二分查找法
   3. 快慢指针法
   4. 滑动窗口法
   5. 跨数组多指针
9. 哈希表`HashMap`
   1. 查找
   2. 缓存
10. 栈`Stack`
   1. `push/pop`
11. 队列`Queue`
   1. `Queue`是接口，实现类是`LinkedList/ArrayDeque`
   2. `offer/poll`
12. 动态规划dp
   1. 推导转移方程并填充`dp[]`数组
13. 排序算法
    1. 堆PriorityQueue
